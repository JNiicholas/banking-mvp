= Project Documentation
Jonas Iqbal <jonas@iqbal.dk>
:toc: left
:sectnums:
:icons: font
:revnumber: {revnumber}
:revdate: {revdate}

== Introduction
This documentation covers the architecture and key components of the Spring Boot banking application. The application provides secure and robust banking features including account management, transaction processing, and customer data handling. It leverages Spring Boot's ecosystem for building RESTful services, integrates with a PostgreSQL database, and implements security and concurrency controls to ensure data integrity and user authentication.

:imagesdir: images
image::logo.png[width=120,align=left]

== How to Run Locally

[source,bash]
----
./mvnw spring-boot:run
----

== API Documentation

*API Docs:* link:http://localhost:8080/swagger-ui.html[Swagger UI]

OpenAPI spec (JSON): link:http://localhost:8080/v3/api-docs[ /v3/api-docs ]

== Architecture

The following diagram shows the high-level components:

[plantuml, target=architecture, format=svg]
....
@startuml
title High-Level Architecture

actor User
rectangle "Frontend (Angular)" as FE
rectangle "Keycloak (IdP)" as KC
node "Spring Boot" as SB {
  [Controller] --> [Service]
  [Service] --> [Repository]
}
database "PostgreSQL" as DB

User --> FE
FE --> KC : OIDC login
FE --> SB : API calls with JWT
SB --> KC : validate token
[Repository] --> DB
@enduml
....

The architecture of the application is layered to promote separation of concerns and maintainability. The Controller layer handles HTTP requests and responses, delegating business logic to the Service layer. Services encapsulate core business rules and transaction management, ensuring atomic operations and consistency. The Repository layer interacts directly with the PostgreSQL database, using JPA/Hibernate for ORM. To maintain data integrity during concurrent operations, the application employs optimistic locking on entities such as Account, using a version field. Transactions are managed declaratively via Spring’s `@Transactional` annotations, ensuring rollback on failures and consistency across multiple operations.

== Database

The application manages three primary entities: Account, Transaction, and Customer. An Account holds balance and version information for optimistic locking and belongs to a Customer. Transactions record individual operations on accounts, including type, amount, resulting balance, and timestamp.

[plantuml, target=db-schema, format=svg]
....
@startuml
entity "Customer" as CUSTOMER {
  * id : UUID <<PK>>
  --
  first_name : varchar(50)
  last_name  : varchar(50)
  email      : varchar(255)
  external_auth_id    : UUID
  external_auth_realm : varchar(64)
}

entity "Account" as ACCOUNT {
  * id : UUID <<PK>>
  --
  customer_id   : UUID <<FK Customer.id>>
  balance       : numeric(19,4)
  version       : bigint
  iban_country  : varchar(2)
  iban_normalized : varchar(34)
  iban_display    : varchar(42)
}

entity "Transaction" as TX {
  * id : UUID <<PK>>
  --
  account_id    : UUID <<FK Account.id>>
  timestamp     : timestamptz
  type          : varchar(16)
  amount        : numeric(19,4)
  balance_after : numeric(19,4)
}

CUSTOMER ||--o{ ACCOUNT
ACCOUNT  ||--o{ TX
@enduml
....

Database schema versioning and migrations are managed using Flyway, which applies incremental SQL scripts to keep the database schema in sync with the application. For development, PostgreSQL is run via docker-compose, ensuring an isolated and reproducible environment for testing and deployment.

== Security


The application secures endpoints using OAuth2 login integrated with Keycloak as the identity provider. Configuration includes specifying the issuer-uri and accepted audiences to validate JWT tokens. This setup enables single sign-on and centralized user management. For testing API security, Postman can be configured to obtain OAuth2 tokens from Keycloak and include them in requests, facilitating end-to-end security verification.

*Keycloak Admin Console:* link:http://localhost:8081/admin/[http://localhost:8081/admin/]

*Realm export (preconfigured settings)*::
A ready-to-import Keycloak realm configuration is provided under `config/keycloak/realm-export/` in this repository. It contains the realm, client(s), roles, and example users used by this project.

How to use:
- **Admin console import**: In Keycloak, go to *Realm settings → Import*, select the JSON from `config/keycloak/realm-export/`, and import.
- **Docker start with import** (optional): Mount the folder and start Keycloak with `--import-realm` so the realm is auto‑imported on startup.

This is the exact configuration the application expects by default, so importing it ensures JWT audiences/roles/clients match the backend security configuration.

== Logging

A custom `TraceIdFilter` and a `JwtLoggingFilter` provide rich, per-request observability.

*Trace ID (request correlation)*::
We generate a unique **traceId** at the very beginning of the servlet chain and store it in the Mapped Diagnostic Context (MDC). The same value is also written to the response header **`X-Trace-Id`** so clients (Postman, browser, other services) can copy it into bug reports or dashboards and instantly correlate a client call with all backend log lines for that request.

Benefits:
- End‑to‑end correlation across services and threads (every log line for the request carries the same traceId).
- Fast production triage: copy the `X-Trace-Id` from a failed response and grep the logs.
- Works even for 401/403/500 because the traceId is created before authentication/handler execution.

How to use it from clients:
[source,bash]
----
# Make a request and capture the header
curl -i http://localhost:8080/customers

# Response excerpt:
HTTP/1.1 200
X-Trace-Id: 7f1333bbb0a94bfaa345fd98e78c5905
----

Then search logs with that id:
[source,bash]
----
grep 7f1333bbb0a94bfaa345fd98e78c5905 application.log
----

Sample lines (abbreviated):
[source,log]
----
INFO TraceIdFilter - Request started: method=GET, uri=/customers, traceId=7f1333bbb0a94bfaa345fd98e78c5905
INFO TraceIdFilter - Request completed: method=GET, uri=/customers, status=200, traceId=7f1333bbb0a94bfaa345fd98e78c5905
----

*JWT logging*::
After Spring Security authenticates the request and populates the `SecurityContext`, a dedicated `JwtLoggingFilter` logs **non-sensitive** JWT claims to help understand *who* made the call:
- `sub` (subject / user id), `preferred_username`, `email`
- `iss` (issuer/realm), `aud` (audiences), `azp` (authorized party), scopes/roles
- The same `traceId` is included so security events correlate with the request.

Example (abbreviated):
[source,log]
----
INFO JwtLoggingFilter - JWT details: sub=..., preferred_username=..., email=..., iss=..., azp=..., aud=[...], scope=..., roles=[...], traceId=7f1333bbb0a94bfaa345fd98e78c5905
----

We intentionally avoid logging token values themselves or highly sensitive claims.

*Filter ordering &amp; lifecycle*::
Servlet filters execute in chain order. We register:
1. **TraceIdFilter** — runs **first** (highest precedence). It creates the traceId, puts it in MDC, and sets `X-Trace-Id`. All later logs inherit the MDC value.
2. **Spring Security filter chain** — performs authentication/authorization and builds the `SecurityContext`.
3. **JwtLoggingFilter** — runs **after** security so it can safely read the authenticated `Jwt` (if any) and log selected claims together with the traceId.
4. Application handlers, then response flows back through the chain.

In Spring Boot this ordering is enforced by either:
- Annotating filters with `@Order` (lower number = earlier), or
- Registering with `FilterRegistrationBean#setOrder`. We assign TraceIdFilter a higher precedence (smaller order value) than JwtLoggingFilter, and ensure JwtLoggingFilter executes after the security chain (e.g., `Ordered.LOWEST_PRECEDENCE - 10`).

This setup guarantees that every log line includes a traceId and—when authenticated—helpful, privacy‑aware JWT context.

== Mapping

MapStruct is used for mapping between entity objects and Data Transfer Objects (DTOs). This compile-time code generation approach ensures type-safe, efficient, and maintainable mappings, reducing boilerplate code in the service and controller layers.

== Validation

Input validation is enforced on deposit and withdrawal operations to ensure data integrity and business rules compliance. This includes checks for positive amounts, sufficient funds for withdrawals, and adherence to account constraints, preventing invalid or inconsistent transactions.

== Testing

The application includes comprehensive integration tests that cover API endpoints, service logic, and database interactions. Special attention is given to concurrency scenarios to verify that optimistic locking prevents race conditions. Tests also ensure overdraft prevention logic works correctly, maintaining account balances within allowed limits.

== Additional Topics

Additional features include resilience4j integration for fault tolerance, including circuit breakers and retry mechanisms to enhance system robustness. The build process incorporates the OWASP dependency-check plugin to identify and mitigate known vulnerabilities in third-party libraries, improving the application's security posture.

== Project Lombok

Project Lombok reduces Java boilerplate (getters/setters, constructors, builders, logging) by generating code at **compile time** via annotation processing. Lombok hooks into the Java compiler and modifies the **javac Abstract Syntax Tree (AST)** (often called the *compile tree*). When you annotate a class (e.g., with `@Getter`, `@Setter`, `@Builder`, `@Value`), Lombok injects the corresponding fields/methods into the AST *before* bytecode is written, so the generated members are present in the compiled classes but not in your source files.

Key points:
- **Annotation processor**: Lombok runs as a compile-time processor that alters the AST. This is why IDEs must enable **annotation processing** and usually need the **Lombok plugin** for correct code insight.
- **Common annotations**: `@Getter`, `@Setter`, `@ToString`, `@EqualsAndHashCode`, `@RequiredArgsConstructor`, `@AllArgsConstructor`, `@NoArgsConstructor`, `@Builder`, `@Value`, `@Data`, and loggers like `@Slf4j`.
- **Delombok**: To inspect generated code or for tools that require explicit sources, use *delombok* to materialize the generated members into plain Java sources.

Official resources:
- Lombok home: https://projectlombok.org
- Feature overview: https://projectlombok.org/features
- IDE setup / annotation processing: https://projectlombok.org/setup/overview
- Delombok: https://projectlombok.org/features/delombok


== OWASP Dependency-Check

We use **OWASP Dependency-Check** to identify known CVEs in third-party dependencies. It analyzes project artifacts (Maven, Gradle, etc.), matches them to vulnerability data (NVD/CPE), and produces a report.

How to run with Maven (typical commands):

[source,bash]
----
# Run a scan and generate a report
mvn -U org.owasp:dependency-check-maven:check

# (Optional) Only update the local vulnerability database
mvn org.owasp:dependency-check-maven:updateonly
----

Where to find the report:

- HTML report: `target/dependency-check-report.html`
- JSON/XML variants: `target/dependency-check-report.json` / `target/dependency-check-report.xml`

Useful configuration (in `pom.xml` under the plugin):

[source,xml]
----
<configuration>
  <!-- Fail the build if a vulnerability with CVSS >= 7.0 is found -->
  <failOnCVSS>7.0</failOnCVSS>
  <!-- Optionally point to a suppression file for false positives -->
  <!-- <suppressionFiles> <suppressionFile>dependency-check-suppressions.xml</suppressionFile> </suppressionFiles> -->
  <!-- Use an NVD API key from environment (see below) -->
  <nvdApiKey>${env.NVD_API_KEY}</nvdApiKey>
</configuration>
----

Obtaining and using an **NVD API Key** (recommended for reliable, faster database updates):

1. Request a key from NVD: create an account and obtain an API key.
2. Store it as an environment variable (e.g., `NVD_API_KEY`).
3. Expose it to the plugin via `<nvdApiKey>${env.NVD_API_KEY}</nvdApiKey>` as shown above.

Official resources:
- Dependency-Check docs (Maven): https://jeremylong.github.io/DependencyCheck/dependency-check-maven/index.html
- Project repository: https://github.com/jeremylong/DependencyCheck
- NVD API key request: https://nvd.nist.gov/developers/request-an-api-key

== Login Flow (Sequence)

[plantuml, target=login-seq, format=svg]
....
@startuml
autonumber
actor User
participant "Frontend (Angular)" as FE
participant "Keycloak (IdP)" as KC
participant "Backend (Spring Boot)" as BE
database "DB" as DB

== Interactive Login ==
User -> FE: Click "Login"
FE -> KC: OIDC Authorization Request (code + PKCE)
KC --> User: Login + (optional) consent
User -> KC: Credentials
KC --> FE: Authorization Code (redirect to FE redirect_uri)

== Token Exchange ==
FE -> KC: Exchange Code + code_verifier
KC --> FE: { access_token (JWT), refresh_token, id_token }

== API Calls ==
FE -> BE: HTTPS API call with Authorization: Bearer access_token
BE -> BE: Validate JWT (issuer, signature/JWKS, expiry,\naudience contains [Angular-Banking-App, Banking-App])
BE -> KC: (optional) JWKS fetch (cached)
BE -> DB: Business operation
DB --> BE: Data
BE --> FE: 200 OK + response JSON

== Refresh ==
FE -> KC: Refresh Token Grant (refresh_token)
KC --> FE: New access_token (+ optional new refresh_token)
@enduml
....

== Keycloak & OIDC (Authorization Code + PKCE)

*Why OIDC with PKCE?*
The SPA (Angular) is a public client with no client secret. **PKCE** adds a one-time proof (`code_verifier`/`code_challenge`) so an intercepted authorization code cannot be exchanged by an attacker.

*Main steps (high level)*:
1. **Authorization request** from the browser to Keycloak with `response_type=code` and `code_challenge`.
2. **User authentication** (login, MFA, consent depending on realm policy).
3. **Authorization code** returned to the SPA on the registered `redirect_uri`.
4. **Code exchange** (SPA → Keycloak) with `code_verifier` → returns:
   - **access_token** (JWT, short-lived) – used on every API call in `Authorization: Bearer …`
   - **refresh_token** (opaque/JWT, longer-lived) – used to obtain a new access token without re-login
   - **id_token** (JWT) – user profile for the client (not sent to the API)
5. **API calls** – the SPA sends the *access token*; the backend **validates** it (issuer, signature, expiry, **audience**).

*Access vs Refresh token*:
- **Access Token**: short TTL, carries scopes/roles (`realm_access.roles`) and `aud`. If expired, API returns `401`.
- **Refresh Token**: longer TTL, used by SPA to silently get a new access token (until refresh token expires or is revoked).

== JWT Structure (What the encoded token looks like)

A JWT is three Base64URL parts separated by dots:

[source,text]
----
eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJodHRwOi8v... (payload) ... . (signature)
└──── header ─────┘ └──────────── payload (claims) ───────────┘ └── signature ──┘
----

*Header (example)*:
[source,json]
----
{
  "alg": "RS256",
  "typ": "JWT",
  "kid": "abc123"   // Key id for JWKS selection
}
----

*Payload (example – relevant claims)*:
[source,json]
----
{
  "iss": "http://localhost:8081/realms/BankingApp",
  "aud": ["Angular-Banking-App", "Banking-App"],
  "azp": "Angular-Banking-App",
  "exp": 1759078930,
  "iat": 1759078630,
  "sub": "ef...7adf",               // Subject (user id)
  "email": "user@example.com",
  "given_name": "Banking",
  "family_name": "User",
  "preferred_username": "banking-user",
  "realm_access": { "roles": ["user","admin"] }
}
----

*Signature*:
- Created by Keycloak private key (RS256).
- Backend verifies using **JWKS** (Keycloak’s public keys).

[plantuml, target=jwt-structure, format=svg]
....
@startuml
title JWT Layout
rectangle "Header\n{\n alg: RS256\n typ: JWT\n kid: ...\n}" as H #DDFFDD
rectangle "Payload (Claims)\n{\n iss, aud, sub, exp,\n email, given_name, family_name,\n realm_access.roles\n}" as P #DDDDFF
rectangle "Signature\nRS256(private_key)" as S #FFDDDD
H -[hidden]- P
P -[hidden]- S
@enduml
....

== Spring Security (JWT, Roles & Audience)

The backend is a **resource server**: it validates incoming Keycloak JWTs and authorizes requests using **realm roles**.

*Validation steps (per request)*:
1. **Issuer** – token `iss` must match the configured Keycloak realm issuer (e.g. `http://localhost:8081/realms/BankingApp`).
2. **Signature (JWKS)** – the `kid` in the header selects the public key from the realm’s JWKS; the signature is verified.
3. **Expiry / Not Before** – `exp`/`nbf` are enforced.
4. **Audience** – token `aud` **must include** all **expected audiences**:
   `Angular-Banking-App,Banking-App`
   This prevents tokens minted for other clients from being accepted.
5. **Authorities (roles)** – we map `realm_access.roles` → `GrantedAuthority` (e.g., `ROLE_user`, `ROLE_admin`) and can use:
   - `@PreAuthorize("hasRole('admin')")`
   - `@PreAuthorize("@authz.canReadAccount(authentication, #id)")`

*Typical configuration (conceptual)*:
[source,java]
----
@Bean
SecurityFilterChain security(HttpSecurity http) throws Exception {
  http
    .csrf(csrf -> csrf.disable())
    .authorizeHttpRequests(auth -> auth
      .requestMatchers("/public/**").permitAll()
      .requestMatchers("/admin/**").hasRole("admin")
      .anyRequest().authenticated()
    )
    .oauth2ResourceServer(oauth2 -> oauth2
      .jwt(jwt -> jwt
        .jwtAuthenticationConverter(realmRoleConverter())
        .decoder(jwtDecoderWithAudience())
      )
    );
  return http.build();
}

@Bean
Converter<Jwt, ? extends AbstractAuthenticationToken> realmRoleConverter() {
  // Extract roles from realm_access.roles and prefix with ROLE_
}

@Bean
JwtDecoder jwtDecoderWithAudience() {
  // Configure decoder with issuer + audience validator requiring
  // ["Angular-Banking-App","Banking-App"]
}
----

This ensures:
- Only tokens from your Keycloak realm are accepted.
- Only tokens **intended** for your API (audiences) pass.
- Role checks use **realm roles** from `realm_access.roles`.




== Checkstyle
We use **Checkstyle** to enforce consistent Java coding standards and avoid common style issues.
Run Checkstyle locally with Maven:
mvn checkstyle:check       # Run checks and fail the build if violations exist
mvn checkstyle:checkstyle  # Generate a report without failing the build

Reports:
- Console output when using `check`
- HTML report available at `target/site/checkstyle.html` when using `checkstyle`

Rules:
- Defined in `config/checkstyle/checkstyle.xml`
- Suppressions (e.g. generated code) can be added to `config/checkstyle/suppressions.xml`

Official documentation: https://checkstyle.org

== Configuration
You can externalize configuration via `application.yml`:

[source,yaml]
----
server:
  port: 8081
spring:
  datasource:
    url: jdbc:postgresql://localhost:5432/app
    username: app
    password: secret
----